import ProductCategorization from '../models/ProductCategorization.js';
import Product from '../models/Product.js';
import catchAsyncErrors from '../middleware/catchAsyncErrors.js';
import ErrorHandler from '../utils/errorHandler.js';

// Auto-categorize product using AI
export const autoCategorizProduct = catchAsyncErrors(async (req, res, next) => {
  const { productId } = req.params;

  const product = await Product.findById(productId);
  if (!product) {
    return next(new ErrorHandler('Product not found', 404));
  }

  // Simulate AI analysis (integrate with OpenAI/Hugging Face in production)
  const imageAnalysis = {
    dominantColors: ['blue', 'white', 'black'],
    detectedObjects: ['clothing', 'fabric', 'pattern'],
    style: 'casual',
    season: 'summer',
    occasion: 'everyday'
  };

  const textAnalysis = {
    keywords: extractKeywords(product.name + ' ' + product.description),
    sentiment: 'positive',
    language: 'en'
  };

  const autoGeneratedTags = [
    { tag: 'summer', confidence: 0.95, source: 'image_analysis' },
    { tag: 'casual', confidence: 0.89, source: 'text_analysis' },
    { tag: 'comfortable', confidence: 0.87, source: 'text_analysis' }
  ];

  let categorization = await ProductCategorization.findOne({ product: productId });

  if (categorization) {
    categorization.autoGeneratedTags = autoGeneratedTags;
    categorization.imageAnalysis = imageAnalysis;
    categorization.textAnalysis = textAnalysis;
    categorization.lastAnalyzed = Date.now();
  } else {
    categorization = await ProductCategorization.create({
      product: productId,
      autoGeneratedTags,
      imageAnalysis,
      textAnalysis
    });
  }

  await categorization.save();

  res.status(200).json({
    success: true,
    data: categorization
  });
});

// Get product categorization
export const getProductCategorization = catchAsyncErrors(async (req, res, next) => {
  const categorization = await ProductCategorization.findOne({
    product: req.params.productId
  }).populate('product');

  if (!categorization) {
    return next(new ErrorHandler('Categorization not found', 404));
  }

  res.status(200).json({
    success: true,
    data: categorization
  });
});

// Batch categorize products
export const batchCategorizeProducts = catchAsyncErrors(async (req, res, next) => {
  const { productIds } = req.body;

  const results = [];
  for (const productId of productIds) {
    try {
      const product = await Product.findById(productId);
      if (!product) continue;

      const autoGeneratedTags = [
        { tag: 'auto-tagged', confidence: 0.8, source: 'text_analysis' }
      ];

      let categorization = await ProductCategorization.findOne({ product: productId });

      if (categorization) {
        categorization.autoGeneratedTags = autoGeneratedTags;
        categorization.lastAnalyzed = Date.now();
        await categorization.save();
      } else {
        categorization = await ProductCategorization.create({
          product: productId,
          autoGeneratedTags
        });
      }

      results.push({ productId, success: true });
    } catch (error) {
      results.push({ productId, success: false, error: error.message });
    }
  }

  res.status(200).json({
    success: true,
    data: results
  });
});

// Review and approve auto-categorization
export const reviewCategorization = catchAsyncErrors(async (req, res, next) => {
  const { approved, tags, categories } = req.body;

  const categorization = await ProductCategorization.findOne({
    product: req.params.productId
  });

  if (!categorization) {
    return next(new ErrorHandler('Categorization not found', 404));
  }

  if (approved) {
    if (tags) categorization.autoGeneratedTags = tags;
    if (categories) categorization.categories = categories;

    categorization.needsReview = false;
    categorization.reviewedBy = req.user.id;
    categorization.reviewedAt = Date.now();
  }

  await categorization.save();

  res.status(200).json({
    success: true,
    data: categorization
  });
});

// Helper function
function extractKeywords(text) {
  const stopWords = ['the', 'is', 'at', 'which', 'on', 'a', 'an', 'and', 'or', 'but'];
  const words = text.toLowerCase().match(/\b(\w+)\b/g) || [];
  return words
    .filter(word => !stopWords.includes(word) && word.length > 3)
    .slice(0, 10);
}
