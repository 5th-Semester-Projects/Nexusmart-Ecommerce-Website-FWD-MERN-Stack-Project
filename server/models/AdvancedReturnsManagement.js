import mongoose from 'mongoose';

const advancedReturnsManagementSchema = new mongoose.Schema({
  order: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Order',
    required: true,
    index: true
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  seller: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    index: true
  },

  // Return Request Details
  returnId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  returnType: {
    type: String,
    enum: ['return', 'exchange', 'refund', 'warranty-claim'],
    required: true
  },

  // Items to Return
  items: [{
    product: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Product',
      required: true
    },
    orderItem: mongoose.Schema.Types.Mixed,
    quantity: {
      type: Number,
      required: true,
      min: 1
    },
    reason: {
      type: String,
      enum: ['defective', 'wrong-item', 'not-as-described', 'size-issue', 'color-different',
        'damaged-shipping', 'late-delivery', 'changed-mind', 'found-better-price', 'quality-issue', 'other'],
      required: true
    },
    reasonDetails: String,
    images: [String],
    videos: [String],
    conditionNotes: String,
    refundAmount: {
      type: Number,
      required: true
    }
  }],

  // QR Code Returns
  qrCode: {
    enabled: {
      type: Boolean,
      default: true
    },
    qrCodeUrl: String,
    qrCodeData: String,
    generatedAt: Date,
    scannedAt: Date,
    scannedLocation: String,
    returnCenter: {
      name: String,
      address: String,
      contactNumber: String
    }
  },

  // Return Method
  returnMethod: {
    type: {
      type: String,
      enum: ['ship-back', 'drop-off', 'pickup', 'in-store'],
      required: true
    },
    shippingLabel: {
      url: String,
      trackingNumber: String,
      carrier: String,
      generatedAt: Date,
      cost: {
        type: Number,
        default: 0
      },
      paidBy: {
        type: String,
        enum: ['seller', 'customer', 'shared']
      }
    },
    dropOffLocation: {
      name: String,
      address: String,
      hours: String,
      deadline: Date
    },
    pickupDetails: {
      scheduledDate: Date,
      timeSlot: String,
      address: String,
      instructions: String,
      status: {
        type: String,
        enum: ['scheduled', 'confirmed', 'picked-up', 'failed']
      }
    }
  },

  // Instant Refund
  instantRefund: {
    eligible: {
      type: Boolean,
      default: false
    },
    approved: {
      type: Boolean,
      default: false
    },
    amount: Number,
    processedAt: Date,
    refundMethod: {
      type: String,
      enum: ['original-payment', 'store-credit', 'gift-card', 'bank-transfer']
    },
    transactionId: String,
    estimatedArrival: Date
  },

  // Exchange Suggestions
  exchangeSuggestions: {
    enabled: {
      type: Boolean,
      default: true
    },
    suggestions: [{
      product: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Product'
      },
      reason: {
        type: String,
        enum: ['similar-product', 'size-variant', 'color-variant', 'upgraded-version', 'popular-alternative']
      },
      priceDifference: Number,
      availableForExchange: {
        type: Boolean,
        default: true
      },
      selected: {
        type: Boolean,
        default: false
      }
    }],
    autoGenerated: {
      type: Boolean,
      default: true
    }
  },

  // Return Status
  status: {
    type: String,
    enum: ['requested', 'approved', 'rejected', 'label-generated', 'in-transit',
      'received', 'inspecting', 'approved-refund', 'refunded', 'completed', 'cancelled'],
    default: 'requested',
    index: true
  },
  statusHistory: [{
    status: String,
    timestamp: {
      type: Date,
      default: Date.now
    },
    note: String,
    updatedBy: {
      type: String,
      enum: ['customer', 'seller', 'system', 'support']
    }
  }],

  // Inspection Results
  inspection: {
    inspectedAt: Date,
    inspectedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    condition: {
      type: String,
      enum: ['as-new', 'good', 'acceptable', 'damaged', 'unusable']
    },
    notes: String,
    images: [String],
    passed: {
      type: Boolean,
      default: false
    },
    failureReason: String,
    refundAdjustment: {
      originalAmount: Number,
      adjustedAmount: Number,
      deductionReason: String
    }
  },

  // Refund Details
  refund: {
    totalAmount: {
      type: Number,
      required: true
    },
    productAmount: Number,
    shippingAmount: Number,
    taxAmount: Number,
    restockingFee: {
      type: Number,
      default: 0
    },
    deductions: [{
      reason: String,
      amount: Number
    }],
    finalAmount: Number,
    method: {
      type: String,
      enum: ['original-payment', 'store-credit', 'gift-card', 'bank-transfer', 'wallet']
    },
    status: {
      type: String,
      enum: ['pending', 'processing', 'completed', 'failed'],
      default: 'pending'
    },
    processedAt: Date,
    transactionId: String,
    estimatedDays: {
      type: Number,
      default: 7
    }
  },

  // Return Reasons Analytics
  returnReasonAnalytics: {
    primaryReason: String,
    subReasons: [String],
    customerFeedback: {
      rating: {
        type: Number,
        min: 1,
        max: 5
      },
      comment: String,
      wouldRepurchase: Boolean
    },
    productQualityScore: {
      type: Number,
      min: 1,
      max: 10
    }
  },

  // Communication
  communications: [{
    from: {
      type: String,
      enum: ['customer', 'seller', 'support', 'system']
    },
    to: {
      type: String,
      enum: ['customer', 'seller', 'support']
    },
    type: {
      type: String,
      enum: ['message', 'email', 'sms', 'notification']
    },
    subject: String,
    message: String,
    timestamp: {
      type: Date,
      default: Date.now
    },
    read: {
      type: Boolean,
      default: false
    }
  }],

  // Approval Workflow
  approvalWorkflow: {
    requiresApproval: {
      type: Boolean,
      default: true
    },
    autoApproveConditions: {
      withinDays: Number,
      maxValue: Number,
      reasons: [String]
    },
    approvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    approvedAt: Date,
    approvalNote: String,
    rejectedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    rejectedAt: Date,
    rejectionReason: String
  },

  // Replacement Order
  replacementOrder: {
    created: {
      type: Boolean,
      default: false
    },
    orderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Order'
    },
    items: [{
      product: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Product'
      },
      quantity: Number,
      price: Number
    }],
    shippingCost: Number,
    totalCost: Number,
    status: String
  },

  // Policy Compliance
  policyCompliance: {
    returnWindow: {
      orderDate: Date,
      returnDeadline: Date,
      withinWindow: {
        type: Boolean,
        default: true
      },
      daysElapsed: Number
    },
    conditionMet: {
      type: Boolean,
      default: true
    },
    exceptions: [String],
    notes: String
  },

  // Timestamps
  requestedAt: {
    type: Date,
    default: Date.now
  },
  completedAt: Date,

  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true, suppressReservedKeysWarning: true });

// Indexes
// advancedReturnsManagementSchema.index({ user: 1, status: 1 }); // Removed: both user and status already have index:true
// advancedReturnsManagementSchema.index({ order: 1 }); // Removed: order field already has index:true

// Methods
advancedReturnsManagementSchema.methods.generateQRCode = function () {
  const qrData = JSON.stringify({
    returnId: this.returnId,
    orderId: this.order,
    userId: this.user,
    timestamp: Date.now()
  });

  this.qrCode.qrCodeData = qrData;
  this.qrCode.generatedAt = Date.now();
  this.qrCode.qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?data=${encodeURIComponent(qrData)}&size=300x300`;

  return this.save();
};

advancedReturnsManagementSchema.methods.approveReturn = function (approvedBy, note) {
  this.status = 'approved';
  this.approvalWorkflow.approvedBy = approvedBy;
  this.approvalWorkflow.approvedAt = Date.now();
  this.approvalWorkflow.approvalNote = note;

  this.statusHistory.push({
    status: 'approved',
    timestamp: Date.now(),
    note: note,
    updatedBy: 'seller'
  });

  return this.save();
};

advancedReturnsManagementSchema.methods.processInstantRefund = function () {
  this.instantRefund.approved = true;
  this.instantRefund.processedAt = Date.now();
  this.instantRefund.estimatedArrival = new Date(Date.now() + (3 * 24 * 60 * 60 * 1000));

  this.refund.status = 'completed';
  this.refund.processedAt = Date.now();

  this.status = 'refunded';

  return this.save();
};

advancedReturnsManagementSchema.methods.inspectReturn = function (inspectionData) {
  this.inspection = {
    inspectedAt: Date.now(),
    inspectedBy: inspectionData.inspectedBy,
    condition: inspectionData.condition,
    notes: inspectionData.notes,
    images: inspectionData.images || [],
    passed: inspectionData.passed
  };

  if (inspectionData.passed) {
    this.status = 'approved-refund';
  } else {
    this.inspection.failureReason = inspectionData.failureReason;
  }

  this.statusHistory.push({
    status: this.status,
    timestamp: Date.now(),
    note: inspectionData.notes,
    updatedBy: 'seller'
  });

  return this.save();
};

// Statics
advancedReturnsManagementSchema.statics.getPendingReturns = function (sellerId) {
  return this.find({
    seller: sellerId,
    status: { $in: ['requested', 'approved', 'in-transit', 'received', 'inspecting'] }
  })
    .populate('user order items.product')
    .sort({ requestedAt: -1 });
};

advancedReturnsManagementSchema.statics.getReturnAnalytics = function (sellerId, startDate, endDate) {
  return this.aggregate([
    {
      $match: {
        seller: mongoose.Types.ObjectId(sellerId),
        requestedAt: { $gte: new Date(startDate), $lte: new Date(endDate) }
      }
    },
    {
      $group: {
        _id: '$items.reason',
        count: { $sum: 1 },
        totalRefunded: { $sum: '$refund.finalAmount' }
      }
    },
    {
      $sort: { count: -1 }
    }
  ]);
};

const AdvancedReturnsManagement = mongoose.model('AdvancedReturnsManagement', advancedReturnsManagementSchema);

export default AdvancedReturnsManagement;
